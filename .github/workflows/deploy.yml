name: CD - Continuous Deployment

on:
  push:
    branches: [ main ]
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
          - staging
          - production

env:
  PYTHON_VERSION: '3.12'
  NODE_VERSION: '20'
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Build and push Docker images
  build-images:
    name: Build Docker Images
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    
    outputs:
      backend-image: ${{ steps.meta-backend.outputs.tags }}
      frontend-image: ${{ steps.meta-frontend.outputs.tags }}
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract backend metadata
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/backend
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha
    
    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile.backend
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Extract frontend metadata
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/frontend
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha
    
    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Deploy to Staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: build-images
    if: github.ref == 'refs/heads/main' || github.event.inputs.environment == 'staging'
    # environment: staging  # Create this in GitHub repo settings: Settings > Environments > New environment
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Deploy to staging server
      run: |
        echo "ğŸš€ Deploying to staging environment"
        echo "Backend image: ${{ needs.build-images.outputs.backend-image }}"
        echo "Frontend image: ${{ needs.build-images.outputs.frontend-image }}"
        # Add actual deployment commands here (e.g., kubectl, docker-compose, etc.)
        # Example:
        # ssh deploy@staging.server 'cd /app && docker-compose pull && docker-compose up -d'
    
    - name: Run database migrations
      run: |
        echo "ğŸ—„ï¸ Running database migrations"
        # Example:
        # ssh deploy@staging.server 'cd /app && docker-compose exec backend python manage.py migrate'
    
    - name: Verify deployment
      run: |
        echo "âœ… Verifying staging deployment"
        # Example health check:
        # curl -f https://staging.nzila-export.com/health || exit 1
    
    - name: Notify on Slack
      if: always()
      run: |
        echo "ğŸ“¢ Would notify Slack about staging deployment"
        # Add Slack webhook integration

  # Run integration tests on staging
  integration-tests:
    name: Integration Tests (Staging)
    runs-on: ubuntu-latest
    needs: deploy-staging
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
    
    - name: Run integration tests
      env:
        STAGING_URL: https://staging.nzila-export.com
      run: |
        echo "ğŸ§ª Running integration tests against staging"
        # Example:
        # pip install pytest requests
        # pytest tests/integration/ --base-url=$STAGING_URL
    
    - name: Run smoke tests
      run: |
        echo "ğŸ”¥ Running smoke tests"
        # Example:
        # curl -f $STAGING_URL/api/health
        # curl -f $STAGING_URL/api/vehicles/

  # Deploy to Production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-images, integration-tests]
    if: startsWith(github.ref, 'refs/tags/v') || github.event.inputs.environment == 'production'
    # environment: production  # Create this in GitHub repo settings: Settings > Environments > New environment
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Create deployment backup
      run: |
        echo "ğŸ’¾ Creating database backup"
        # Example:
        # ssh deploy@prod.server 'cd /app && ./backup.sh'
    
    - name: Deploy to production
      run: |
        echo "ğŸš€ Deploying to production environment"
        echo "Backend image: ${{ needs.build-images.outputs.backend-image }}"
        echo "Frontend image: ${{ needs.build-images.outputs.frontend-image }}"
        # Add actual deployment commands
    
    - name: Run database migrations
      run: |
        echo "ğŸ—„ï¸ Running database migrations"
        # Example:
        # ssh deploy@prod.server 'cd /app && docker-compose exec backend python manage.py migrate'
    
    - name: Warm up cache
      run: |
        echo "â™¨ï¸ Warming up application cache"
        # Example:
        # curl https://nzila-export.com/api/vehicles/?page=1
    
    - name: Verify production deployment
      run: |
        echo "âœ… Verifying production deployment"
        # Health checks
    
    # Uncomment when Sentry is configured:
    # - name: Create Sentry release
    #   if: vars.SENTRY_ENABLED == 'true'
    #   env:
    #     SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
    #     SENTRY_ORG: ${{ vars.SENTRY_ORG }}
    #     SENTRY_PROJECT: ${{ vars.SENTRY_PROJECT }}
    #   run: |
    #     echo "ğŸ“Š Creating Sentry release"
    #     # To enable: Add SENTRY_ENABLED='true' in repo Variables and SENTRY_AUTH_TOKEN in Secrets
    #     # curl -sL https://sentry.io/get-cli/ | bash
    #     # sentry-cli releases new "${{ github.ref_name }}"
    #     # sentry-cli releases set-commits "${{ github.ref_name }}" --auto
    #     # sentry-cli releases finalize "${{ github.ref_name }}"
    
    - name: Notify team
      if: always()
      run: |
        echo "ğŸ“¢ Notifying team about production deployment"
        # Slack/Email notifications

  # Rollback capability
  rollback:
    name: Rollback Production
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'workflow_dispatch'
    needs: deploy-production
    # environment: production  # Create this in GitHub repo settings: Settings > Environments > New environment
    
    steps:
    - name: Rollback to previous version
      run: |
        echo "âª Rolling back to previous version"
        # Implement rollback logic
        # Example:
        # ssh deploy@prod.server 'cd /app && ./rollback.sh'
    
    - name: Verify rollback
      run: |
        echo "âœ… Verifying rollback"
        # Health checks
    
    - name: Notify team
      run: |
        echo "ğŸš¨ Notifying team about rollback"
